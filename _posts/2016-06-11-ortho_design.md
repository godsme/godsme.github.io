---
layout: post
title: "变化驱动：正交设计"
date:   2016-06-10 19:39:14
time: 2016年06月10日 星期六
categories: software design
location: 深圳,中国
---

一个出发点
===
当谈起**软件设计**的目的时，能够获得所有人认同的答案只有一个：**功能实现**。 因为这是一个软件存在的根本原因。
而在计算机软件发展的初期，这一点也正是所有人做软件设计的唯一动机。因而，很自然的，整个软件都被放在单一过程中，然后用到处存在的goto语句控制流程。
尽管理论上讲,任意复杂的系统都可以被放入同一个函数里。但随着软件越来复杂，即便是智商最为发达的程序员也发现，单一过程的复杂度已经超出他的掌控极限。这逼迫人们必须对大问题进行分解，分而治之。
时至今日，尽管超大函数，**上帝类**依然并不罕见，但当大到一定程度，**上帝类**的创造者最终也会发现自己终究没有上帝般的掌控力。因而，哪怕是软件设计素养为负值的开发者，或多或少也会对一个复杂系统进行一定程度的拆分。
这就是**模块化设计**的最初动机。

两个问题
===

一旦人们开始进行进行模块化拆分，就必须解决如下两个问题:1. 究竟软件模块该怎样划分才是合理的?2. 将一个大单元划分为多个小单元之后，它们之间必然要通过**衔接点**进行合作。如果我们把这些衔接点看作API，那么问题就变为：怎样定义API才是合理的?
更简单的说：**怎么分**？然后再**怎么合**？

<img src="https://godsme.github.io/img/module.png" width="300px" />而这两个问题的答案，正是现代软件设计的核心关注点。

三方关系
===
为了找到这两个问题的答案，我们需要重新回到最初的问题：为何要做软件设计?
Kent Beck给出的答案是：*软件设计是为了在让软件在长期范围内容易应对变化*。
在这个精炼的定义中，包含着三个关键词：**长期**，**容易**，**变化**。这意味着:
1. 越是需要长期维护的项目，变化更多，也更难预测变化的方式;2. 软件设计，事关成本;3. 如何在难以预测的千变万化中，保持低廉的变更成本，正是软件设计要解决的问题。
对此，Kent Beck提出了一个更为精炼的原则：**局部化影响**。意思是说,我们希望，任何一个变化，对于我们当前的软件设计影响范围都可以控制在一个尽量小的局部。
这当然是所有严肃的软件从业者都梦寐以求的。

可问题在于,如何才能做到?内聚与耦合
---
每个读过基础软件工程教程的人都知道：一个易于应对变化的软件设计应该遵从**高内聚，低耦合**原则。

￼所谓**内聚性**，关注的是一个软件单位内部的关联紧密程度。因而高内聚追求的是*关联紧密的事物应该被放在一起*，并且*只有关联紧密的事物才应该被放在一起*。简单说，就是Unix的设计哲学：

>Do One Thing, Do It Well。
而**耦合性**，则是强调两个或多个软件单位之间的关联紧密程度。因而**低耦合**追求的是，软件单位之间尽可能不要相互影响。这样的解释，对于很多人而言，依然会感到过于抽象。但如果我们进一步思考, 就会意识到：看似神秘的**内聚**与**耦合**,正好对应最初的两个问题:
1. 当我们划分模块时,要让每个模块都尽可能**高内聚**; 
2. 而当我们定义模块之间的API时，需要让双方尽可能**低耦合**。
如果用图来展现,就是下面的过程与关系:<img src="https://godsme.github.io/img/orth1.png" width="300px" />
这幅图揭示了**模块化设计**的全部：首先将一个**低内聚**的模块首先拆分为多个**高内聚**的模块；然后再考虑这多个模块之间的API设计，以降低这些**高内聚**的软件单元之间的**耦合度**。
除了**内聚**与**耦合**之外，上面这幅图还揭示了另外一种关系：**正交**。具备**正交**关系的两个模块，可以做到一方的变化不会影响另外一方的变化。换句话说，双方各自独自变化，互不影响。
而这幅图的右侧，正是我们模块化的目标。它描述了**永恒的三方关系**：*客户*，*API*，*实现*，以及它们之间的关系。这个三方关系图清晰的指出了我们应该关注的**内聚性**，**耦合性**，以及**正交性**都发生在何处。

四个策略
===
相对于**局部化影响**，**高内聚,低耦合**原则已经清晰和具体许多。但依然更像是在描述目标或结果，而没有指明该如何达成的方法。虽然《代码大全》列举￼了那么多的**内聚性**和**耦合性**的分类，但对于想应用它们的软件设计人员，依然感觉如隔靴挠痒，不得要领。
因而，我们需要从它推导出更为明确，更具指导性和操作性的设计原则。
为了做到这一点，我们必须首先搞清楚：**内聚**与**耦合**，和**变化**之间的关系是怎样的，以至于**高内聚、低耦合**的模块化方式能够更容易应对变化？
我们再次回顾**内聚**与**耦合**的定义：它们是用来衡量代码元素之间的关联紧密程度。很容易得知：元素之间的关联紧密程度越高，一个变化引起它们相互之间都发生变化的可能性就越高。反之，关联程度越弱，变化引起的连锁变化的概率就越低。
因而，我们要把容易互相影响的、关联程度紧密的元素，都封装在一个模块内部（而这正是我们老生常谈的**封装变化**的动机）；同时让模块之间的关联紧密程度尽可能降低，以让模块间尽可能不要相互影响。从而最终做到**局部化影响**。
因而，Uncle Bob说：一个类只应该有一个变化原因。他进一步谈到：所谓一个变化原因，指一个变化会导致整个类所包含的各个元素都要发生变化。为何会如此？因为它们的关联程度太紧密(因而**高内聚)**，以至于牵一发而动全身。
因此，Uncle Bob将**职责**定义为**变化原因**。在一些时候，我们可以直接判定一个模块是否包含多重职责。因为它们确实包含着明显没有什么关联的两组代码元素。

但在另外一些场景下，我们则无法清晰的判定：一个模块是否真的包含多重变化原因，或多重职责。比如如下代码:

``` cppstruct Student 
{  char name[MAX_NAME_LEN];  unsigned int height; 
};
void sort_students_by_height(Student students[], size_t num_of_students) 
{  for(size_t y=0; y < num_of_students-1; y++) 
  {    for(size_t x=1; x < num_of_students - y; x++) 
    {      if(students[x].height > students[x-1].height) 
      { 
        SWAP(students[x], students[x-1]);
      } 
    }  } 
}
```
这是一个“对学生按照身高从低到高进行排序”的算法。对于这段代码，如果我们进行猜测，会发现很多点都有变化的可能，如果对这些变化都进行分离和管理，确实会提高系统的内￼￼聚度。但如果我们现在就将每个变化点都分离出来，无疑会让整个系统陷入巨大的不必要的复杂度。
破解这类难题的方法是：既然我们知道**高内聚,低耦合**的设计是为了软件更容易应对变化的，那么我们为何不反过来，让实际发生的需求变化来驱动我们识别变化，管理变化，从而让我们的系统达到恰如其分的内聚度和耦合度?###策略一：消除重复
首先进入我们射程的就是**重复代码**。编写重复代码不仅仅会让有追求的程序员感到乏味（你的老板才不会关心你的工作是否乏味）。真正致命的是：“重复”极度违背**高内聚、低耦合**原则，从而会大幅提升软件的长期维护成本。
我们之前已经讨论过，所谓**高内聚**，指的是关联紧密的事物应该被放在一起。没有比两段完全相同的代码关联更为紧密。因而重复代码意味着**低内聚**。
而更为糟糕的是，本质重复的代码，其实都在表达（即依赖）同一项知识。如果它们表达（即依赖）的知识发生了变化，这些重复的代码统统都要修改。因而, 重复代码也意味着**高耦合**。

<img src="https://godsme.github.io/img/dup3.png" width="300px" />
因而，对于**完全重复**的代码进行消除，合二为一，会让系统更加**高内聚、低耦合**。 

如果两个模块之间是**部分重复**的，则发出了一个重要的信号：这两个模块都至少存在两个变化原因,或两重职责。
如下图所示，两个模块存在着部分重复。站在系统的角度看，它们之间存在着**不变**的部分（即重复的部分）；也存在**变化**的部分（即差异的部分）。这意味着这两个模块都存在两个变化原因。

<img src="https://godsme.github.io/img/dup4.png" width="300px" />
对于这一类型的重复,比较典型的情况有两种：*调用型重复*，以及*回调型重复*。它们的命名来源于:在重复消除后，重复与差异之间的关系是调用，还是回调。

<img src="https://godsme.github.io/img/dup2.png" width="300px" /><img src="https://godsme.github.io/img/dup1.png" width="300px" />
由此，我们得到了第一个策略：**消除重复**。
这个策略，非常明确，极具可操作性：当你看到重复时，尽力消除它。这个策略，明显提高系统的**内聚性**，降低了**耦合性**。除此之外,还得到一个重大收益：**可重用性**。事实上，消除重复的过程，正是一个提高系统可重用性的过程。
￼￼另外对于**回调型重复**的消除，也是一个提高系统**可扩展性**的过程。

###策略二：分离不同的变化方向
除了重复代码外，另外一个驱动系统朝向高内聚方向演进的信号是：我们经常需要因为*同一类原因*，修改某个模块。而这个模块的其它部分却保持不变。
比如，在之前我们“对学生按照身高从低到高排序”的例子中，如果现在我们需要增加“对老师按照身高从低到高排序”的需求，我们就知道，*排序对象*是一个新的变化方向。于是，我们将代码重构为:

```cpptemplate <typename T>void bulb_sort(T objects[], size_t num_of_objects) 
{  for(size_t y=0; y < num_of_objects - 1; y++) 
  {    for(size_t x=1; x < num_of_objects - y; x++) 
    {      if(objects[x].height > objects[x-1].height) 
      {         SWAP(objects[x], objects[x-1]);      }    } 
  }}
```
如果随后又出现一个新的需求：*按照学生升高从低到高排序*。此时我们知道*排序规则*也是一个变化的方向。因此，我们将这个变化方向也从现有代码中分离出去。然后得到:

```cpptemplate <typename T>void bulb_sort(T objects[], size_t num_of_objects) 
{  for(size_t y=0; y < num_of_objects - 1; y++) 
  {    for(size_t x=1; x < num_of_objects - y; x++) 
    {      if(objects[x] > objects[x-1]) 
      {        SWAP(objects[x], objects[x-1]);      }    } 
  }}
```
**分离不同变化方向**，目标在于提高**内聚度**。因为*多个变化方向*，意味着一个模块存在多重职责。将不同的变化方向进行分离，也意味着各个变化方向职责的单一化。
从这个例子可以看出，此策略的应用时机也非常明确：当你发现需求导致一个变化方向出现时，将其从原有的设计中分离出去。￼￼￼
<img src="https://godsme.github.io/img/change_direct.png" width="300px" />
对于变化方向的分离，也得到了另外一个我们追求的目标：**可扩展性**。
如果我们足够细心，会发现策略**消除重复**和**分离不同变化方向**是两个高度相似和关联的策略:
它们都是关注于如何对原有模块进行拆分，以提高系统的**内聚性**。(虽然同时也往往伴随着**耦合度**的降低，但这些**耦合度**的降低都发生在别处，并未触及该如何定义API以降低客户与API之间**耦合度**)。

另外，如果两个模块有**部分代码**是重复的，往往意味着**不同变化方向**。
尽管如此，我们依然需要两个不同的策略。这是因为：变化方向，并不总是以**重复代码**的形式出现的（其典型症状是散弹式修改，或者if-else、switch-case、模式匹配）；尽管其背后往往存在一个以**重复代码**形式表现的等价形式（这也是为何copy-paste-modify如此流行的原因）。

###策略三：缩小依赖范围
前面两个策略解决了软件单元该如何划分的问题。现在我们需要关注模块之间的**粘合点**——即API——的定义问题。
需要强调的是：两个模块之间并不存在耦合，它们的都共同耦合在API上。因而 API如何定义才能降低**耦合度**，才是我们应该关注的重点。

<img src="https://godsme.github.io/img/couple.png" width="300px" />
从这幅图可以看出，对于API定义所带来的耦合度影响，需要遵循如下原则：

* 首先,客户的数量,以及实现的数量,会对耦合度产生重大的影响。它们数量越多,意味着 API 变更的成本越高,越需要花更大的精力来仔细斟酌。* 其次,对于影响面大的API(也意味着耦合度高)，需要使用更加弹性的API定义框架，以有利于向前兼容性。

而具体到策略**缩小依赖范围**，它强调:1. API 应包含尽可能少的知识。因为任何一项知识的变化都会导致双方的变化; 
2. API 也应该**高内聚**，而不应该强迫API的客户依赖它不需要的东西。

###策略四：向着稳定的方向依赖
但是，无论我们如何**缩小依赖范围**，如果两个模块需要协作，它们之间必然存在耦合点(即API)。降低**耦合度**的努力似乎已经走到了尽头。
我们知道，耦合的最大问题在于：耦合点的变化，会导致依赖方跟着变化。但这也意味着，如果耦合点从来不会变化，那么依赖方也就不会因此而变化。换句话说，耦合点越稳定，依赖方受耦合变化影响的概率就越低。
由此，我们得到最后一个策略：**向着稳定的方向依赖**。
那么，究竟什么样的API更倾向于稳定？不难知道，站在What，而不是How的角度；即站在**需求**的角度，而不是**实现方式**的角度定义API，会让其更加稳定。而需求的提出方，一定是**客户端**，而不是**实现侧**。这就意味着，我们在定义接口时，应该站在客户的角度，思考用户的本质需要，由此来定义API。而不是站在技术实现的方便程度角度来思考API定义。
而这正是**封装**或**信息隐藏**的关键。
###小结
这四个策略，前两者聚焦于*如何划分模块*，后两个聚焦于*如何定义模块间的API*。
这四个策略的背后动力非常明确：**变化驱动**。前两者，都是在明确的变化方向被第一次识别之后（所谓第一颗子弹），进行策略运用，以让模块在变化面前越来越**高内聚**。而后两者，则是在模块职责分离之后，需要定义模块间API时,尽可能考虑不同的API定义方式对于依赖双方的影响。
由于这四个策略致力于让系统朝着更具**正交性**的方向演进，因而它们也被称做**正交四原则**,或者**正交策略**。

总结
---
本文首先从**一个出发点**出发：为了降低软件复杂度，提升可重用性，我们需要**模块化**。 

由此得到了**两个问题**：模块划分必然要解决如何划分,以及模块间如何协作(API 定义)的问题。
基于软件易于应对变化的角度出发。**高内聚,低耦合**原则是最为核心和关键的高层原则。基于此我们得到了在模块化过程中,我们真正需要关注的**三方关系**。
为了让**高内聚、低耦合**更具指导性和操作性，我们提出了**四个策略**。它们以**变化驱动**，让系统逐步向更好的正交性演进的策略，因此也被称做**正交策略**或**正交原则**。

我们已经在多个系统的设计和开发中，以这四个原则来驱动我们的软件设计，不仅让我们的系统在保持简单的同时，具备所有必要的灵活性。也让设计和开发活动变得高度有章可循，让团队生产率得以大幅提升。

